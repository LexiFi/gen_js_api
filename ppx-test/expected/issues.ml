module Issue116 : sig type t end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      type t = Ojs.t
      let rec (t_of_js : Ojs.t -> t) = fun x2 -> x2
      and (t_to_js : t -> Ojs.t) = fun x1 -> x1
    end)[@merlin.hide ]) 
module Issue117 :
  sig
    module T :
    ((sig
        val log : 'a -> unit[@@js.global ]
        val log2 : 'a -> 'b -> unit[@@js.global "jsLog2"]
      end)[@js.scope "console"])
  end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      module T =
        struct
          let (log : 'a -> unit) =
            fun x3 ->
              ignore
                (Ojs.call (Ojs.get Ojs.global "console") "log"
                   [|(Obj.magic x3)|])
          let (log2 : 'a -> 'b -> unit) =
            fun x4 ->
              fun x5 ->
                ignore
                  (Ojs.call (Ojs.get Ojs.global "console") "jsLog2"
                     [|(Obj.magic x4);(Obj.magic x5)|])
        end
    end)[@merlin.hide ]) 
module Issue124 :
  sig
    type 'a dummy
    type 'a wrapped =
      | Wrapped of 'a [@@js.custom
                        {
                          to_js =
                            (let f a_to_js =
                               function | Wrapped a -> a_to_js a in
                             f);
                          of_js =
                            (let f a_of_js x = Wrapped (a_of_js x) in f)
                        }]
    type u =
      | Unknown of Ojs.t [@js.default ]
      | T of t [@js "t"]
      | WrappedT of t wrapped [@js "wrapped_t"][@@js.union on_field "type"]
    and t = [ `U of u ] dummy[@@js.custom
                               { to_js = Obj.magic; of_js = Obj.magic }]
  end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      type 'a dummy = Ojs.t
      let rec (dummy_of_js : (Ojs.t -> 'a) -> Ojs.t -> 'a dummy) =
        fun _ -> fun x7 -> x7
      and (dummy_to_js : ('a -> Ojs.t) -> 'a dummy -> Ojs.t) =
        fun _ -> fun x6 -> x6
      type 'a wrapped =
        | Wrapped of 'a [@@js.custom
                          {
                            to_js =
                              (let f a_to_js =
                                 function | Wrapped a -> a_to_js a in
                               f);
                            of_js =
                              (let f a_of_js x = Wrapped (a_of_js x) in f)
                          }]
      let rec wrapped_of_js = let f a_of_js x = Wrapped (a_of_js x) in f
      and wrapped_to_js =
        let f a_to_js = function | Wrapped a -> a_to_js a in f
      type u =
        | Unknown of Ojs.t [@js.default ]
        | T of t [@js "t"]
        | WrappedT of t wrapped [@js "wrapped_t"][@@js.union on_field "type"]
      and t = [ `U of u ] dummy[@@js.custom
                                 { to_js = Obj.magic; of_js = Obj.magic }]
      let rec (u_of_js : Ojs.t -> u) =
        fun x13 ->
          let x14 = x13 in
          match Ojs.type_of (Ojs.get x14 "type") with
          | "number" ->
              (match Ojs.int_of_js (Ojs.get x14 "type") with
               | _ -> Unknown x14)
          | "string" ->
              (match Ojs.string_of_js (Ojs.get x14 "type") with
               | "t" -> T (t_of_js x14)
               | "wrapped_t" -> WrappedT (wrapped_of_js t_of_js x14)
               | _ -> Unknown x14)
          | "boolean" ->
              (match Ojs.bool_of_js (Ojs.get x14 "type") with
               | _ -> Unknown x14)
          | _ -> Unknown x14
      and (u_to_js : u -> Ojs.t) =
        fun x8 ->
          match x8 with
          | Unknown x9 -> x9
          | T x10 -> t_to_js x10
          | WrappedT x11 -> wrapped_to_js t_to_js x11
      and t_of_js = Obj.magic
      and t_to_js = Obj.magic
    end)[@merlin.hide ]) 
