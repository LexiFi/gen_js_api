module Issue116 : sig type t end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      type t = Ojs.t
      let rec t_of_js : Ojs.t -> t = fun (x2 : Ojs.t) -> x2
      and t_to_js : t -> Ojs.t = fun (x1 : Ojs.t) -> x1
    end)[@merlin.hide ]) 
module Issue117 :
  sig module T : sig val log : 'a -> unit val log2 : 'a -> 'b -> unit end end
  =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      module T =
        struct
          let (log : 'a -> unit) =
            fun (x3 : 'a) ->
              ignore
                (Ojs.call (Ojs.get_prop_ascii Ojs.global "console") "log"
                   [|(Obj.magic x3)|])
          let (log2 : 'a -> 'b -> unit) =
            fun (x4 : 'a) ->
              fun (x5 : 'b) ->
                ignore
                  (Ojs.call (Ojs.get_prop_ascii Ojs.global "console")
                     "jsLog2" [|(Obj.magic x4);(Obj.magic x5)|])
        end
    end)[@merlin.hide ]) 
module Issue124 :
  sig
    type a
    and b = {
      a: a }
    type 'a dummy
    type 'a wrapped =
      | Wrapped of 'a 
    type u =
      | Unknown of Ojs.t 
      | T of t 
      | WrappedT of t wrapped 
    and t = [ `U of u ] dummy
    type ('a, 'b) base = [ `BaseA of 'a  | `BaseB of 'b ] dummy
    and base1 = (int, string) base
    and base2 = (string, int) base
  end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      type a = Ojs.t
      and b = {
        a: a }
      let rec a_of_js : Ojs.t -> a = fun (x7 : Ojs.t) -> x7
      and a_to_js : a -> Ojs.t = fun (x6 : Ojs.t) -> x6
      and b_of_js : Ojs.t -> b = fun js -> { a = (a_of_js js) }
      and b_to_js : b -> Ojs.t = fun { a } -> a_to_js a
      type 'a dummy = Ojs.t
      let rec dummy_of_js : 'a . (Ojs.t -> 'a) -> Ojs.t -> 'a dummy = fun
        (type __a) ->
        fun (__a_of_js : Ojs.t -> __a) -> fun (x9 : Ojs.t) -> x9
      and dummy_to_js : 'a . ('a -> Ojs.t) -> 'a dummy -> Ojs.t = fun (type
        __a) -> fun (__a_to_js : __a -> Ojs.t) -> fun (x8 : Ojs.t) -> x8
      type 'a wrapped =
        | Wrapped of 'a 
      let rec wrapped_of_js : 'a . (Ojs.t -> 'a) -> Ojs.t -> 'a wrapped =
        let f a_of_js x = Wrapped (a_of_js x) in f
      and wrapped_to_js : 'a . ('a -> Ojs.t) -> 'a wrapped -> Ojs.t =
        let f a_to_js = function | Wrapped a -> a_to_js a in f
      type u =
        | Unknown of Ojs.t 
        | T of t 
        | WrappedT of t wrapped 
      and t = [ `U of u ] dummy
      let rec u_of_js : Ojs.t -> u =
        fun (x15 : Ojs.t) ->
          let x16 = x15 in
          match Ojs.type_of (Ojs.get_prop_ascii x16 "type") with
          | "number" -> Unknown x16
          | "string" ->
              (match Ojs.string_of_js (Ojs.get_prop_ascii x16 "type") with
               | "t" -> T (t_of_js x16)
               | "wrapped_t" -> WrappedT (wrapped_of_js t_of_js x16)
               | _ -> Unknown x16)
          | "boolean" -> Unknown x16
          | _ -> Unknown x16
      and u_to_js : u -> Ojs.t =
        fun (x10 : u) ->
          match x10 with
          | Unknown x11 -> x11
          | T x12 -> t_to_js x12
          | WrappedT x13 -> wrapped_to_js t_to_js x13
      and t_of_js : Ojs.t -> t = Obj.magic
      and t_to_js : t -> Ojs.t = Obj.magic
      type ('a, 'b) base = [ `BaseA of 'a  | `BaseB of 'b ] dummy
      and base1 = (int, string) base
      and base2 = (string, int) base
      let rec base_of_js :
        'a 'b . (Ojs.t -> 'a) -> (Ojs.t -> 'b) -> Ojs.t -> ('a, 'b) base =
        fun _ -> fun _ -> Obj.magic
      and base_to_js :
        'a 'b . ('a -> Ojs.t) -> ('b -> Ojs.t) -> ('a, 'b) base -> Ojs.t =
        fun _ -> fun _ -> Obj.magic
      and base1_of_js : Ojs.t -> base1 =
        fun (x21 : Ojs.t) -> base_of_js Ojs.int_of_js Ojs.string_of_js x21
      and base1_to_js : base1 -> Ojs.t =
        fun (x18 : (int, string) base) ->
          base_to_js Ojs.int_to_js Ojs.string_to_js x18
      and base2_of_js : Ojs.t -> base2 =
        fun (x27 : Ojs.t) -> base_of_js Ojs.string_of_js Ojs.int_of_js x27
      and base2_to_js : base2 -> Ojs.t =
        fun (x24 : (string, int) base) ->
          base_to_js Ojs.string_to_js Ojs.int_to_js x24
    end)[@merlin.hide ]) 
module Issue109 : sig type t = [ `S of string  | `I of int ] end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      type t = [ `S of string  | `I of int ]
      let rec t_of_js : Ojs.t -> t =
        fun (x35 : Ojs.t) ->
          let x36 = x35 in
          match Ojs.type_of x36 with
          | "number" -> (match Ojs.int_of_js x36 with | x38 -> `I x38)
          | "string" -> (match Ojs.string_of_js x36 with | x37 -> `S x37)
          | _ -> assert false
      and t_to_js : t -> Ojs.t =
        fun (x32 : [ `S of string  | `I of int ]) ->
          match x32 with
          | `S x33 -> Ojs.string_to_js x33
          | `I x34 -> Ojs.int_to_js x34
    end)[@merlin.hide ]) 
module Issue142 : sig type t = [ `Foo ]
                      and u = t end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      type t = [ `Foo ]
      and u = t
      let rec t_of_js : Ojs.t -> t =
        fun (x40 : Ojs.t) ->
          let x41 = x40 in
          match Ojs.int_of_js x41 with | 42 -> `Foo | _ -> assert false
      and t_to_js : t -> Ojs.t =
        fun (x39 : [ `Foo ]) -> match x39 with | `Foo -> Ojs.int_to_js 42
      and u_of_js : Ojs.t -> u = fun (x43 : Ojs.t) -> t_of_js x43
      and u_to_js : u -> Ojs.t = fun (x42 : t) -> t_to_js x42
    end)[@merlin.hide ]) 
module Issue144 : sig type t val f : t -> args:int -> int end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      type t = Ojs.t
      let rec t_of_js : Ojs.t -> t = fun (x45 : Ojs.t) -> x45
      and t_to_js : t -> Ojs.t = fun (x44 : Ojs.t) -> x44
      let (f : t -> args:int -> int) =
        fun (x46 : t) ->
          fun ~args:(x47 : int) ->
            Ojs.int_of_js
              (Ojs.apply (Ojs.call (t_to_js x46) "f" [||])
                 [|(Ojs.int_to_js x47)|])
    end)[@merlin.hide ]) 
module Issue146 : sig val f : ?arg:[ `Foo ] -> unit -> int end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      let (f : ?arg:[ `Foo ] -> unit -> int) =
        fun ?arg:(x48 : [ `Foo ] option) ->
          fun () ->
            Ojs.int_of_js
              (let x51 = Ojs.global in
               Ojs.call (Ojs.get_prop_ascii x51 "f") "apply"
                 [|x51;((let x49 =
                           Ojs.new_obj
                             (Ojs.get_prop_ascii Ojs.global "Array") 
                             [||] in
                         (match x48 with
                          | Some x50 ->
                              ignore
                                (Ojs.call x49 "push"
                                   [|((match x50 with
                                       | `Foo -> Ojs.int_to_js 42))|])
                          | None -> ());
                         x49))|])
    end)[@merlin.hide ]) 
module PR165 :
  sig
    module Markdown : sig type t end
    module ParameterInformation :
    sig
      type t
      val create :
        label:[ `String of string  | `Tuple of (int * int) ] ->
          ?documentation:[ `String of string  | `Markdown of Markdown.t ] ->
            unit -> t
    end
  end =
  ((struct
      [@@@js.dummy "!! This code has been generated by gen_js_api !!"]
      [@@@ocaml.warning "-7-32-39"]
      module Markdown =
        struct
          type t = Ojs.t
          let rec t_of_js : Ojs.t -> t = fun (x53 : Ojs.t) -> x53
          and t_to_js : t -> Ojs.t = fun (x52 : Ojs.t) -> x52
        end
      module ParameterInformation =
        struct
          type t = Ojs.t
          let rec t_of_js : Ojs.t -> t = fun (x55 : Ojs.t) -> x55
          and t_to_js : t -> Ojs.t = fun (x54 : Ojs.t) -> x54
          let (create :
            label:[ `String of string  | `Tuple of (int * int) ] ->
              ?documentation:[ `String of string  | `Markdown of Markdown.t ]
                -> unit -> t)
            =
            fun ~label:(x56 : [ `String of string  | `Tuple of (int * int) ])
              ->
              fun
                ?documentation:(x57 :
                                 [ `String of string 
                                 | `Markdown of Markdown.t ] option)
                ->
                fun () ->
                  t_of_js
                    (Ojs.new_obj_arr
                       (Ojs.get_prop_ascii Ojs.global "ParameterInformation")
                       (let x58 =
                          Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array")
                            [||] in
                        ignore
                          (Ojs.call x58 "push"
                             [|((match x56 with
                                 | `String x62 -> Ojs.string_to_js x62
                                 | `Tuple x63 ->
                                     let (x64, x65) = x63 in
                                     let x66 = Ojs.array_make 2 in
                                     (Ojs.array_set x66 0 (Ojs.int_to_js x64);
                                      Ojs.array_set x66 1 (Ojs.int_to_js x65);
                                      x66)))|]);
                        (match x57 with
                         | Some x59 ->
                             ignore
                               (Ojs.call x58 "push"
                                  [|((match x59 with
                                      | `String x60 -> Ojs.string_to_js x60
                                      | `Markdown x61 -> Markdown.t_to_js x61))|])
                         | None -> ());
                        x58))
        end
    end)[@merlin.hide ]) 
